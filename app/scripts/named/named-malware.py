import gzip
from datetime import datetime
import struct, socket
import logging
import os,sys
import MySQLdb
import glob
import yaml
from __builtin__ import None
from sys import exc_info

appPath = os.path.abspath(os.path.dirname(os.path.realpath(__file__)) + "/../../")
sys.path.append(appPath + "/lib/pylib")

from pull_config import Configurator
configr = Configurator()

# Credentials used for the database connection
configr = Configurator()
DB = configr.get_var('db')
HOST = configr.get_var('db_host')
USERNAME = configr.get_var('db_user')
PASSWORD = configr.get_var('db_pass')


#logging set up
logger = logging.getLogger('named_malware.py')
hdlr = logging.FileHandler(appPath + '/logs/message_log')
error_hdlr = logging.FileHandler(appPath + '/logs/error_log')
formatter = logging.Formatter('%(asctime)s %(levelname)s %(name)s: %(message)s')
hdlr.setFormatter(formatter)
error_hdlr.setFormatter(formatter)
error_hdlr.setLevel(logging.ERROR)
logger.addHandler(hdlr) 
logger.addHandler(error_hdlr)
logger.setLevel(logging.DEBUG)
logger.debug('args: [\''+('\', \''.join(sys.argv))+'\']')

#config vars
named_dir = configr.get_var('approot')+"app/scripts/named/"

#parse args and read import config
if len(sys.argv)< 2:
    logger.error('Config file path required')
    exit(1)

try:    
    import_config=yaml.load(open(sys.argv[1],'r').read())
except:
    logger.error('Error loading config file: {0}'.format(sys.argv[1]))

whitelisted_ips = set(import_config['whitelisted_ips'])
src = import_config['named_src']
src_id = -1 #pre database lookup value
chunksize = import_config['chunksize']
archive = import_config['archive']

current_year = datetime.today().year
current_month = datetime.today().month
domains = {}
ips={}
uniq_set = set()
count = 0
domain_lookups = 0
domain_inserts = 0
conn = None
cursor = None


def connect_db():
    global conn,cursor
    logger.info("Opening database connection")
    conn = MySQLdb.connect(host=HOST,
      user=USERNAME,
      passwd=PASSWORD,
      db=DB)
    cursor = conn.cursor()

def convert_date(d):
    dt=datetime.strptime(d,"%b %d %H:%M:%S")
    if current_month<12 and dt.month==12:
        dt=dt.replace(year=current_year-1)
    else:
        dt=dt.replace(year=current_year)
    return dt.strftime("%Y-%m-%d %H:%M:%S")

def is_dns_resolution(l):
    return len(l)>8 and l[5]=='client' and l[8]=='query:'

def is_unique(record):
    global uniq_set
    if record in uniq_set:
        return False
    uniq_set.add(record)
    return True

def get_date(l):
    date = ' '.join(l[:3])
    return convert_date(date)

def get_ip(ip):
    ip = ip.split('#')[0]
    if ip in ips:
        ip_numeric=ips[ip]
    else:
        try:
            ip_numeric = struct.unpack('>L',socket.inet_aton(ip))[0]
        except:
            ip_numeric = -1
            logger.error('error with ip numeric for record: {0}'.format(str(l)))
            raise
        ips[ip]=ip_numeric
    return ip,ip_numeric

def load_domains():
    global domains
    query = "SELECT domain_id, domain_name from domain where domain_is_malicious > 0"
    try:
        cursor.execute(query)
    except AttributeError:
        logger.debug('no connection to db. calling connect_db')
        connect_db()
        cursor.execute(query)
    res = cursor.fetchall()
    for record in res:
        domains[record[1].lower()] = int(record[0])
    
    
def get_domain_id(domain):
    global domain_inserts
    global domains
    if len(domains)==0:
        load_domains()
    domain = domain.lower()
    if not domain in domains:
        return -1;
    domain_id = domains[domain]
    return domain_id
        
    

def get_src_id(src):
    global src_id
    
    if src_id>=0:
        return src_id
    
    query='select named_src_id from named_src where named_src_name=%s' 
    try:
        cursor.execute(query,(src,))
    except:
        db_connect()
        cursor.execute(query,(src,))
    res = cursor.fetchone()
    if res == None:
        query = 'insert into named_src set named_src_name=%s'
        cursor.execute(query,(src,))
        conn.commit()
        src_id = int(cursor.lastrowid)
    else:
        src_id = int(res[0])
            
    return src_id

def proc_line(line):
    l = line.split()
    if is_dns_resolution(l):
        dm_id = get_domain_id(l[9])
        if dm_id > -1:
            ip,ip_numeric = get_ip(l[6])
            if ip not in whitelisted_ips:
                date = get_date(l)
                src_id = get_src_id(src)
                return ','.join(str(x) for x in [date,ip,ip_numeric,dm_id,src_id])
    return -1

def proc_file(filepath,archive_filepath,chunk_filepath_template,chunksize):
    logger.debug('processing file: {0}'.format(filepath))
    logger.debug('chunk size: {0}'.format(chunksize))
    count = 0
    fnumber = 0
    fchunkout=None
    chunk =''
    fin = gzip.open(filepath,'r')
    for l in fin:
        res = proc_line(l)
        if res != -1 and is_unique(res):
            chunk+=res+'\n'
            count+=1
            if count % chunksize == 0:
                conn.commit()
                chunk_filepath = chunk_filepath_template.format(fnumber)
                write_data(chunk,archive_filepath,chunk_filepath)
                fnumber+=1
                chunk = ''
                
    if chunk!='':
        chunk_filepath = chunk_filepath_template.format(fnumber)
        write_data(chunk,archive_filepath,chunk_filepath)
        fnumber+=1
    fin.close()
    conn.commit()           
    logger.info('{0} records written to {1} chunk files'.format(count,fnumber))
    logger.info('{0} domains added.'.format(domain_inserts))
    return fnumber
                
def write_data(data, archive_filepath, chunk_filepath):
    if archive:
        logger.debug('writing to archive file: {0}'.format(archive_filepath))
        archivefile = gzip.open(archive_filepath,'a')
        archivefile.write(data)
        archivefile.close()
    logger.debug('writing to chunk file: {0}'.format(chunk_filepath))
    with open(chunk_filepath,'w') as chunkfile:
        chunkfile.write(data)
    
def import_chunks(chunks,chunk_filepath_template):
    query = "load data local infile %s into table named_resolution fields terminated by ',' lines terminated by '\n' " + \
            "(named_resolution_datetime,named_resolution_src_ip,named_resolution_src_ip_numeric,domain_id, named_src_id)"
    for i in chunks:
        logger.info('importing chunk: {0:03d}'.format(i))
        try:
            cursor.execute(query,(chunk_filepath_template.format(i),))
            conn.commit()
        except AttributeError:
            logger.debug('no connection to db. calling connect_db')
            connect_db()
            cursor.execute(query,(chunk_filepath_template.format(i),))
            conn.commit()
        except:
            logger.error('import chunks error', exc_info=True)
            raise
        logger.info('importing chunk complete.')

def delete_chunks(chunks,chunk_filepath_template):
    logger.info("Cleaning up chunk files.")
    for i in chunks:
        chunk_filepath=chunk_filepath_template.format(i)
        logger.debug('removing file: {0}'.format(chunk_filepath))
        os.remove(chunk_filepath)

if __name__=='__main__':
    logger.info('named.py starting')
    archive_dir=named_dir+'archive/'+src+'/'
    chunk_dir=named_dir+'chunks/'+src+'/'
    try:
         os.makedirs(archive_dir)
    except OSError:
        logger.debug('dir exists:{0}'.format(archive_dir))
        
    try:
         os.makedirs(chunk_dir)
    except OSError:
        logger.debug('dir exists:{0}'.format(chunk_dir))
        
    for f in glob.glob(named_dir+'to_load/{0}/*.{0}.log.gz'.format(src)):
        uniq_set = set()
        count = 0
        domain_lookups = 0
        domain_inserts = 0
        filepath=f
        basename=os.path.basename(f).split('.log.gz')[0]
        chunk_filepath_template=chunk_dir+basename+'.{0}.csv'
        archive_filepath=archive_dir+basename+'.csv.gz'
        num_chunks = proc_file(filepath,archive_filepath,chunk_filepath_template,chunksize)
        import_chunks(xrange(num_chunks),chunk_filepath_template)
        delete_chunks(xrange(num_chunks),chunk_filepath_template)
        os.remove(f)
    conn.close()
    logger.info('named.py complete')